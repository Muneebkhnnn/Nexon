So this line:

Buffer.from(data, 'binary').toString('base64')


means:

Take the raw binary response (data)

Convert it into a Node.js Buffer

Encode it as a Base64 string

Then itâ€™s prefixed with this:

`data:image/png;base64,${...}`


so it becomes a data URL, which looks like:

data:image/png;base64,iVBORw0KGgoAAAANSUhEUgA...


Thatâ€™s what cloudinary.uploader.upload() can understand and upload as an image.

2. The ?? operator
You wrote:

publish ?? false


This means:

If publish is not null and not undefined, use its value.

Otherwise, use false.

Itâ€™s similar to ||, but safer:

publish || false


would treat any falsy value (like 0, "", false) as false,
while publish ?? false only defaults if itâ€™s actually null or undefined.

3.
using memorystorage for multer instead of diskstorage
âœ”ï¸ WHY THIS WORKS
Issue	                                 Fix
Can't use disk path	                Use file.buffer + base64
Cloudinary background removal	     Requires base64 input
Wrong destructure	                Use const file = req.file


4.
updating likes array in postgres text[] column
You have a JavaScript array:

updatedLikes = ["user_1", "user_2"]


But PostgreSQL expects array input in this format:

{user_1,user_2}

EXPLANATION (Very simple)
ğŸ”¹ Suppose current likes are:
updatedLikes = ["user_23", "user_77"];

ğŸ”¹ .join(",") makes:
user_23,user_77

ğŸ”¹ Wrapping with {} makes:
{user_23,user_77}

ğŸ”¹ Now Postgres understands it as a text[] array.

Better, cleaner method (Recommended)

Instead of doing manual formatting, use Drizzle/Postgres built-in support:

await sql`
  UPDATE creations 
  SET likes = ${sql.array(updatedLikes, 'text')} 
  WHERE id=${creationId}
`;


This avoids string formatting completely and is safer.